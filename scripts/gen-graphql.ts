// scripts/gen-graphql.ts
import fs from 'fs';
import path from 'path';
// works with Prisma 5/6
import { getDMMF } from '@prisma/internals';

const scalarMap: Record<string,string> = {
  String:'String', Int:'Int', BigInt:'String', Float:'Float',
  Boolean:'Boolean', DateTime:'String', Json:'JSON', Bytes:'String', Decimal:'String'
};

const pluralize = (n:string) => n.endsWith('s') ? `${n}List` : n.endsWith('y') ? n.slice(0,-1)+'ies' : `${n}s`;
const camel = (s:string) => s.charAt(0).toLowerCase() + s.slice(1);

function buildTypeDefForModel(model: any) {
  const fields = model.fields.map((f: any) => {
    const g = f.kind === 'scalar' ? (scalarMap[f.type] || 'String') : 'String';
    const list = f.isList ? '[]' : '';
    return `  ${f.name}: ${g}${list}`;
  }).join('\n');
  return `type ${model.name} {\n${fields}\n}`;
}

function buildQuerySignatureForModel(model: any) {
  const listName = pluralize(camel(model.name));
  const args: string[] = [];
  for (const f of model.fields) {
    if (f.kind !== 'scalar' || f.isList) continue;
    const g = scalarMap[f.type] || 'String';
    args.push(`${f.name}: ${g}`);
  }
  args.push('limit: Int = 100', 'offset: Int = 0');
  return `  ${listName}(${args.join(', ')}): [${model.name}!]`;
}

function buildResolverForModel(model: any) {
  const listName = pluralize(camel(model.name));
  const prismaAccessor = camel(model.name);
  const whereLines: string[] = [];
  for (const f of model.fields) {
    if (f.kind !== 'scalar' || f.isList) continue;
    whereLines.push(`...(args.${f.name} !== undefined ? { ${f.name}: args.${f.name} } : {})`);
  }
  const hasId = model.fields.some((f: any) => f.name === 'id');

  return `
    ${listName}: async (_: any, args: any, { prisma }: any) => {
      const where = { ${whereLines.join(', ')} };
      return prisma.${prismaAccessor}.findMany({
        where,
        orderBy: ${hasId ? `[{ id: 'asc' }]` : `undefined`},
        take: Math.min(args.limit ?? 100, 1000),
        skip: args.offset ?? 0
      });
    }`;
}

async function generate() {
  const schemaPath = path.resolve(process.cwd(), 'prisma', 'schema.prisma');
  const datamodel = fs.readFileSync(schemaPath, 'utf8');   // <-- read actual schema text
  const dmmf = await getDMMF({ datamodel });               // <-- pass text, not path
  const models = dmmf.datamodel.models;

  const typeBlocks = models.map(buildTypeDefForModel).join('\n\n');
  const queryBlocks = models.map(buildQuerySignatureForModel).join('\n');
  const resolverBlocks = models.map(buildResolverForModel).join(',');

  const typeDefs = `
  scalar JSON

  ${typeBlocks}

  type Query {
${queryBlocks}
  }`;

  const file = `// AUTO-GENERATED by scripts/gen-graphql.ts
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import express from 'express';
import cors from 'cors';
import { json } from 'body-parser';
import { PrismaClient } from '@prisma/client';
import { CFG } from './config';

const prisma = new PrismaClient();

const JSONScalar = {
  __serialize(v: any) { return v; },
  __parseValue(v: any) { return v; },
  __parseLiteral(ast: any) { return (ast && (ast.value ?? ast.fields)) ?? null; },
};

const typeDefs = /* GraphQL */ \`
${typeDefs.trim()}
\`;

const resolvers = {
  JSON: JSONScalar,
  Query: {${resolverBlocks}
  }
};

export async function startGraphQL() {
  const server = new ApolloServer({ typeDefs, resolvers });
  await server.start();

  const app = express();
  app.use(cors(), json(), expressMiddleware(server, { context: async () => ({ prisma }) }));

  app.listen(CFG.gqlPort, () => {
    console.log(\`ðŸš€ GraphQL ready at http://0.0.0.0:\${CFG.gqlPort}/\`);
  });
}
`;

  const outPath = path.resolve(process.cwd(), 'src', 'graphql.ts');
  fs.writeFileSync(outPath, file);
  console.log(`Generated ${outPath}`);
}

generate().catch((e) => {
  console.error('gen-graphql failed:', e);
  process.exit(1);
});
